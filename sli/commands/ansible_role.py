import os
from pathlib import Path
from typing import Tuple

import yaml
from git import Git
from git import Repo

from .base import BaseCommand
from sli.decorators import require_ngfw_connection_params, require_panoply_connection

from jinja2 import Template
from sli.tools import format_xml_string
from .diff import DiffCommand
from ..errors import InvalidArgumentsException
from ..errors import SLIException


class AnsibleRoleCommand(DiffCommand):
    sli_command = "ansible_role"
    short_desc = (
        "Builds an Ansible Role from the differences between two config versions, candidate, running, "
        "previous running, etc"
    )
    no_skillet = True
    repo_url = "https://gitlab.com/panw-gse/as/pan_community-ansible-collection-skeleton.git"
    help_text = """
        ansible_role module requires 0 to 3 arguments.

        - 0 arguments: Diff running config from previous running config
        - 1 argument: Diff previous config or named config against specified running config
        - 2 arguments: Diff first arg named config against second arg named config
        - 3 arguments: Diff first arg named config against second arg named config and save diffs into the context

        A named config can be either a stored config, candidate, running or a number.
        Positive numbers must be used to specify iterations, 1 means 1 config revision ago

        Example: Get diff between running config and previous running config

            user$ sli ansible_role 1 -uc  -od /tmp/roles

        Example: Get diff between running config and the candidate config

            user$ sli ansible_role running candidate -uc -od /tmp/roles

        Example: Get the diff of all changes made to this device using the autogenerated 'baseline' config, which is
        essentially blank.

            user$ sli ansible_role baseline -uc -od /tmp/roles

        Example: Get the diff between the second and third most recent running configs

            user$ sli ansible_role 3 2 -uc -od /tmp/roles
    """

    # def _parse_args(self) -> Tuple[str, str]:
    #
    #     if self.sli.options.get("output_directory") is None:
    #         raise InvalidArgumentsException('You must specify an output directory for this command!')
    #
    #     return super()._parse_args()

    @staticmethod
    def __write_file_to_location(file_path_root: Path, file_name: str, file_contents: str) -> None:

        file_path = file_path_root.joinpath(file_name).resolve()

        if not file_path_root.exists():
            raise SLIException("Could not write file!")

        with file_path.open(mode="w") as fp:
            fp.write(file_contents)

    @staticmethod
    def __get_input(var_label: str, var_default: str) -> str:
        val = input(f"{var_label} <{var_default}>: ")
        if val is None or val == "":
            val = var_default

        return val

    def _handle_diff(self, diff) -> None:

        if not len(diff):
            print("No Configuration diffs found! Try a different combination of configuration sources")
            exit(1)

        namespace = self.__get_input("Namespace", "pan_community")
        role_name = self.__get_input("Role Name", "generated_role")
        description = self.__get_input("Role Description", "generated_role")
        author_name = self.__get_input("Author Name", "john doe")

        output_dir: str = self.sli.options.get("output_directory")

        if output_dir is None:
            output_dir = "./ansible_collections"

        if output_dir.startswith("./"):
            output_path = Path(os.getcwd()).joinpath(output_dir).resolve()
        else:
            output_path = Path(output_dir)
            if not output_path.exists() and not output_path.parent.exists():
                raise InvalidArgumentsException("Output directory does not exist!")

        if output_dir != "ansible_collections":
            output_path = output_path.joinpath("ansible_collections")
            output_path.mkdir()

        Repo.clone_from(self.repo_url, output_path)

        # rename the directory structure appropriately
        # it comes from the skeleton repo as
        # example/
        #   skeleton/
        #       roles/
        #           skeleton/

        # rename example to namespace
        top_level = output_path.joinpath("example")
        namespace_path = output_path.joinpath(namespace)
        top_level.rename(namespace_path)

        # rename skeleton to role_name
        skeleton = namespace_path.joinpath("skeleton")
        collection_path = skeleton.parent.joinpath(role_name)
        skeleton.rename(collection_path)

        # rename roles/skeleton to roles/role_name
        skeleton_role_path = collection_path.joinpath("roles/skeleton")
        role_path = skeleton_role_path.parent.joinpath(role_name)
        skeleton_role_path.rename(role_path)

        # write out galaxy.yml file from template
        galaxy_skillet = self._load_app_skillet("ansible_galaxy_template")

        output = galaxy_skillet.execute(
            {"role_name": role_name, "description": description, "author_name": author_name}
        )

        self.__write_file_to_location(collection_path, "galaxy.yml", output["template"])

        # get version and major version from connected NGFW
        version = self.pan.facts["sw-version"]
        major_version = ".".join(version.split(".")[0:2])

        # add major version to supported_versions list
        supported_versions = [major_version]

        # create role vars file
        vars_file_data = dict()
        vars_file_data["supported_version"] = supported_versions
        supported_versions_yaml = yaml.safe_dump(vars_file_data)

        role_vars_path = role_path.joinpath("vars")
        self.__write_file_to_location(role_vars_path, "main.yml", supported_versions_yaml)

        # create version specific task file
        role_tasks_path = role_path.joinpath("tasks")
        ansible_task_template = self._load_app_skillet("ansible_task_template")
        task_output = ansible_task_template.execute({"snippets": diff})
        self.__write_file_to_location(role_tasks_path, f"panos-{major_version}.yml", task_output["template"])

        print(f"Ansible Role created in {output_path} successfully!")

    @require_ngfw_connection_params
    @require_panoply_connection
    def run(self, pan):
        """Get a diff of running and candidate configs"""

        import pydevd_pycharm

        pydevd_pycharm.settrace("localhost", port=45443, stdoutToServer=True, stderrToServer=True, suspend=False)

        self.pan = pan

        try:
            source_name, latest_name = self._parse_args()

        except InvalidArgumentsException as iae:
            self._print_usage()
            print(f"Error: {iae}")
            return

        diff = self._get_diffs(source_name, latest_name)
        self._update_context(diff)
        self._handle_diff(diff)
